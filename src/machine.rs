pub mod basic_machine {
    use crate::assembler::assembler::{consume_box_closure, make_execution_procedure};
    use crate::infrastructure::register::Register;
    use crate::infrastructure::stack::Stack;
    use crate::memory::memory::Memory;
    use crate::parserfordev::parser::{exp_to_str, str_to_exp};
    use crate::primitives::primitives::*;
    use crate::primitives::primitives::{
        announce_output, define_variable, initialize_stack, machine_statistics,
    };
    use crate::representation::type_system::Object;
    use crate::scheme_list;
    use crate::tpfordev::type_system::{append, car, cdr, scheme_cons, Exp, Pair};
    use std::collections::HashMap;
    use std::mem;

    pub struct BasicMachine {
        pub registers: HashMap<String, Register>,
        pub stack: Stack,
        pub semantic_ops: HashMap<String, CallbackExp>,
        pub machine_ops: HashMap<String, Callbackmachine>,
        // instructions that are generated by assembler
        pub instruction_sequence:
            Vec<Option<Box<dyn FnOnce(&mut BasicMachine, &mut Memory) -> Exp>>>,
        // native machine instructions
        pub raw_instructions: Vec<Exp>,
        // label-index pair for instructions
        pub labels: HashMap<String, usize>,
    }

    type CallbackExp = fn(&Exp) -> Exp;
    type Callbackmachine = fn(&mut BasicMachine, &mut Memory) -> Exp;

    impl BasicMachine {
        // Register exp is used to hold the expression to be evaluated
        // Register env contains the environment
        // Register val contains the value obtained by evaluating the expression in
        // designated environment
        // Register continue is used to implement recursion
        // The registers proc, argl, and unev are used in evaluating combinations
        // The registers root, free, scan, old, oldcr, new are used in gc, which shall not
        // be stored in the gc process
        // The registers pc, flag is brought by basic machine
        pub fn initilize_registers(&mut self) {
            self.registers.insert("pc".to_string(), Register::new("PC"));
            self.registers
                .insert("flag".to_string(), Register::new("FLAG"));
            self.registers
                .insert("root".to_string(), Register::new("ROOT"));
            self.registers
                .insert("free".to_string(), Register::new("FREE"));
            self.registers
                .insert("scan".to_string(), Register::new("SCAN"));
            self.registers
                .insert("old".to_string(), Register::new("OLD"));
            self.registers
                .insert("oldcr".to_string(), Register::new("OLDCR"));
            self.registers
                .insert("new".to_string(), Register::new("NEW"));
            self.registers
                .insert("exp".to_string(), Register::new("EXP"));
            self.registers
                .insert("env".to_string(), Register::new("ENV"));
            self.registers
                .insert("unev".to_string(), Register::new("UENV"));
            self.registers
                .insert("continue".to_string(), Register::new("CONTINUE"));
            self.registers
                .insert("val".to_string(), Register::new("VAL"));
            self.registers
                .insert("argl".to_string(), Register::new("ARGL"));
            self.registers
                .insert("proc".to_string(), Register::new("PROC"));
            self.registers
                .insert("benv".to_string(), Register::new("BENV"));
            self.registers
                .insert("cenv".to_string(), Register::new("CENV"));
            self.registers.insert(
                "relocate_continue".to_string(),
                Register::new("RELOCATE_CONTINUE"),
            );
            self.set_register_contents(&"free".to_string(), Object::Index(0));
            self.set_register_contents(&"pc".to_string(), Object::Index(0));
        }

        // after initialization of env, the environment has the form of
        // (((car cdr cons + - *  /) (primitive car) ... (primitive /)))
        #[allow(dead_code)]
        pub fn initialize_env(&mut self, memory: &mut Memory) {
            let mut env = Exp::List(Pair::Nil);
            let primitives = [
                "car", "cdr", "cons", "null?", "+", "-", "*", "/", "<", ">", "=",
            ];
            for item in primitives.iter() {
                let mut p = str_to_exp("(primitive )".to_string());
                let token = Exp::Symbol((**item).to_string());
                p = append(p, token);
                let args = scheme_list!(Exp::Symbol((**item).to_string()), p, env);
                env = define_variable(&args);
            }
            self.set_register_contents_as_in_memory(&"env".to_string(), exp_to_str(env), memory);
        }

        pub fn install_raw_instructions(&mut self, insts: &Exp) {
            if insts.is_null() {
            } else {
                let inst = car(insts).unwrap();
                self.raw_instructions.push(inst);
                self.install_raw_instructions(&cdr(insts).unwrap());
            }
        }

        #[allow(dead_code)]
        pub fn initialize_op(&mut self) {
            let machine_ops = [
                "machine-statistics",
                "initialize-stack",
                "prompt-for-input",
                "read",
            ];
            let semantic_ops = [
                "announce-output",
                "user-print",
                "multiply",
                "division",
                "substract",
                "add",
                "procedure-parameters",
                "procedure-body",
                "make-procedure",
                "operands",
                "operator",
                "empty-arglist",
                "no-operands?",
                "last-operand?",
                "first-operand",
                "rest-operands",
                "meta-apply-primitive-procedure",
                "print-reg-content",
                "print-message",
                "lambda-parameters",
                "lambda-body",
                "adjoin-arg",
                "make-lambda",
                "if-predicate",
                "if-alternative",
                "if-consequent",
                "begin-actions",
                "first-exp",
                "rest-exps",
                "assignment-variable",
                "assignment-value",
                "definition-variable",
                "definition-value",
                "true?",
                "last-exp?",
                "primitive-procedure?",
                "eq?",
                "tagged-list?",
                "variable?",
                "assignment?",
                "definition?",
                "if?",
                "lambda?",
                "begin?",
                "application?",
                "self-evaluating?",
                "compound-procedure?",
                "extend-environment",
                "lookup-variable-value",
                "define-variable!",
                "set-variable-value!",
            ];

            let machine_ops_object = [machine_statistics, initialize_stack, prompt_for_input, read];
            let semantic_ops_object = [
                announce_output,
                user_print,
                multiply,
                division,
                substract,
                add,
                procedure_parameters,
                procedure_body,
                make_procedure,
                operands,
                operator,
                empty_arglist,
                is_no_operands,
                is_last_operand,
                first_operand,
                rest_operands,
                meta_apply_primitive_procedure,
                print_reg_content,
                print_message,
                lambda_parameters,
                lambda_body,
                adjoin_arg,
                make_lambad,
                if_predicate,
                if_alternative,
                if_consequent,
                begin_actions,
                first_exp,
                rest_exps,
                assignment_variable,
                assignment_value,
                definition_variable,
                definition_value,
                is_true,
                is_last_exp,
                is_primitive_procedure,
                is_eq,
                is_tagged_list,
                is_variable,
                is_assignment,
                is_definition,
                is_if,
                is_lambda,
                is_begin,
                is_application,
                is_self_evaluating,
                is_compound_procedure,
                extend_environment,
                lookup_variable_value,
                define_variable,
                set_variable_value,
            ];
            let mut count = 0;
            while count != machine_ops.len() {
                self.add_machine_op((*machine_ops[count]).to_string(), machine_ops_object[count]);
                count += 1;
            }
            count = 0;
            while count != semantic_ops.len() {
                self.add_semantic_op(
                    (*semantic_ops[count]).to_string(),
                    semantic_ops_object[count],
                );
                count += 1;
            }
        }

        #[allow(dead_code)]
        pub fn execute(&mut self, memory: &mut Memory) {
            let reg = self.get_register(&"pc".to_string()).unwrap();
            let index = reg.get_memory_index();
            let max_offset = self.instruction_sequence.len();
            /*
            println!(
                "insts that is running =>  {}",
                exp_to_str(self.raw_instructions[index].clone())
            );
             */
            if index == max_offset {
                println!("Done!");
                return;
            } else {
                let cb = mem::replace(&mut self.instruction_sequence[index], None);
                match cb {
                    Some(x) => {
                        let _r = consume_box_closure(x, self, memory);
                    }
                    None => {
                        let inst = self.raw_instructions[index].clone();
                        let x = make_execution_procedure(inst, self, memory);
                        let _r = consume_box_closure(x, self, memory);
                    }
                }
                self.execute(memory);
            }
        }

        #[allow(dead_code)]
        pub fn add_semantic_op(&mut self, fn_name: String, func: CallbackExp) {
            self.semantic_ops.insert(fn_name, func);
        }

        #[allow(dead_code)]
        pub fn add_machine_op(&mut self, fn_name: String, func: Callbackmachine) {
            self.machine_ops.insert(fn_name, func);
        }

        pub fn call_semantic_op(&mut self, fn_name: String, argv: &Exp) -> Exp {
            self.semantic_ops[&fn_name](argv)
        }

        #[allow(dead_code)]
        pub fn call_machine_op(&mut self, fn_name: String, memory: &mut Memory) -> Exp {
            self.machine_ops[&fn_name](self, memory)
        }

        #[allow(dead_code)]
        pub fn is_semantic_op(&self, fn_name: &String) -> bool {
            self.semantic_ops.contains_key(fn_name)
        }

        #[allow(dead_code)]
        pub fn is_machine_op(&self, fn_name: &String) -> bool {
            self.machine_ops.contains_key(fn_name)
        }

        pub fn new() -> Self {
            let machine = BasicMachine {
                registers: HashMap::new(),
                stack: Stack::new(),
                semantic_ops: HashMap::new(),
                machine_ops: HashMap::new(),
                instruction_sequence: Vec::new(),
                raw_instructions: Vec::new(),
                labels: HashMap::new(),
            };
            machine
        }

        #[allow(dead_code)]
        pub fn print_insts(&mut self) {
            let mut iter = self.raw_instructions.iter().enumerate();
            let mut temp = iter.next();
            while temp != None {
                println!(
                    "{}=> {}",
                    temp.unwrap().0,
                    exp_to_str((*temp.unwrap().1).clone())
                );
                temp = iter.next();
            }
        }

        pub fn get_register(&self, name: &String) -> Option<&Register> {
            self.registers.get(name)
        }

        pub fn get_register_contents_ref(&self, name: String) -> Option<&Object> {
            let item = self.registers.get(&name).clone();
            match item {
                Some(x) => Some(x.get()),
                None => None,
            }
        }

        #[allow(dead_code)]
        pub fn get_register_contents(&self, name: &String) -> Option<Object> {
            let register = self.registers.get(name);
            match register {
                Some(x) => Some((*x.get()).clone()),
                None => None,
            }
        }

        // in this case, a memory address is stored in machine's register
        // a list can be printed by calling this fn
        #[allow(dead_code)]
        pub fn print_register_contents(&self, name: &String, memory: &Memory) {
            let reg = self.get_register(name);
            match reg {
                Some(r) => {
                    r.print_list(memory);
                }
                None => {
                    panic!("No such register exists!");
                }
            }
        }

        // set a Oject directly in some Register
        pub fn set_register_contents(&mut self, name: &String, item: Object) {
            let register = self.registers.get_mut(name);

            match register {
                Some(x) => {
                    x.set(item);
                }
                None => {
                    panic!("No such register in this Machine!");
                }
            }
        }

        // in this case, a list object is wriiten into memory and the beginning address
        // is returned and stored in some register, for specific,
        // set a list in memory from a str and return a index to some register
        // for example, let s = "(1 (2 3))";
        // set s in memory and return the beginning index, such as, 3 to Register root
        #[allow(dead_code)]
        pub fn set_register_contents_as_in_memory(
            &mut self,
            name: &String,
            object: String,
            memory: &mut Memory,
        ) {
            let item = memory.write(object, self);
            self.set_register_contents(name, Object::Index(item));
        }

        #[allow(dead_code)]
        pub fn assign_from_one_register_to_another(&mut self, to: &String, from: &String) {
            let from = self.get_register_contents(&from);
            match from {
                Some(x) => {
                    self.set_register_contents(to, x);
                }
                None => {
                    panic!("No such registers in this Machie or nothing in this register now!");
                }
            }
        }

        #[allow(dead_code)]
        pub fn get_register_contents_as_in_memory(&self, name: &String, memory: &Memory) -> String {
            let reg = self.get_register(name);
            match reg {
                Some(r) => r.get_list_frome_memory_as_str(memory),
                None => {
                    panic!("No such registers exists!");
                }
            }
        }

        #[allow(dead_code)]
        pub fn advance_pc(&mut self) {
            let reg = self.get_register(&"pc".to_string()).unwrap();
            let index = reg.get_memory_index();
            self.set_register_contents(&"pc".to_string(), Object::Index(index + 1));
        }

        #[allow(dead_code)]
        pub fn advance_free(&mut self) {
            let reg = "free".to_string();
            self.register_increment_by_one(&reg);
        }

        #[allow(dead_code)]
        pub fn advance_scan(&mut self) {
            let reg = "scan".to_string();
            self.register_increment_by_one(&reg);
        }

        pub fn register_increment_by_one(&mut self, name: &String) {
            let item = self.get_register_contents_ref(name.clone()).unwrap();
            match item {
                &Object::Index(i) => {
                    let item = Object::Index(i + 1);
                    self.set_register_contents(name, item);
                }
                _ => {
                    panic!("Not a proper index, panic when running register_increment_by_one!")
                }
            }
        }

        /*
            // assign the car part of list of register y to register x
            #[allow(dead_code)]
            pub fn assign_car(&mut self, x: &'static str, y: &'static str, memory: &mut Memory) {}

            // assign the cdr part of list of register y to register x
            #[allow(dead_code)]
            pub fn assign_cdr(&mut self, x: &'static str, y: &'static str, memory: &mut Memory) {}

            // change the car part of list of register x to register y
            #[allow(dead_code)]
            pub fn set_car(&mut self, x: &'static str, y: &'static str, memory: &mut Memory) {}

            // change the cdr part of list of register x to register y
            #[allow(dead_code)]
            pub fn set_cdr(&mut self, x: &'static str, y: &'static str, memory: &mut Memory) {}

            // build a new list from register y and register z, then assign this new list to register x
            #[allow(dead_code)]
            pub fn cons(
                &mut self,
                x: &'static str,
                y: &'static str,
                z: &'static str,
                memory: &mut Memory,
            ) {
            }
        */
    }
}

#[cfg(test)]
mod test {
    use crate::primitives::primitives::{lookup_variable_value, machine_statistics};
    use crate::tpfordev::type_system::{append, scheme_cons};
    use crate::{
        memory::memory::Memory,
        parserfordev::parser::str_to_exp,
        primitives::primitives::{
            assignment_variable, caddr, cadr, is_self_evaluating, is_variable, make_procedure,
        },
        scheme_list,
        tpfordev::type_system::{Exp, Pair},
    };

    use super::basic_machine::BasicMachine;

    #[test]
    fn set_register_contents_as_in_memory_works() {
        let mut memory = Memory::new(20);
        let mut machine = BasicMachine::new();
        machine.initilize_registers();
        let s = "(define x '(+ 1 2))".to_string();
        machine.set_register_contents_as_in_memory(&"root".to_string(), s, &mut memory);
        let ss = machine.get_register_contents_as_in_memory(&"root".to_string(), &memory);
        assert_eq!(ss, String::from("( define x '( + 1 2))"));
        let s = "(3 ())".to_string();
        machine.set_register_contents_as_in_memory(&"exp".to_string(), s, &mut memory);
        let ss = machine.get_register_contents_as_in_memory(&"exp".to_string(), &memory);
        assert_eq!(ss, String::from("( 3())"));
        let s = "()".to_string();
        machine.set_register_contents_as_in_memory(&"exp".to_string(), s, &mut memory);
        let ss = machine.get_register_contents_as_in_memory(&"exp".to_string(), &memory);
        assert_eq!(ss, String::from("()"));
        let s = "(1 (2 () 3) 4 (() 5))".to_string();
        machine.set_register_contents_as_in_memory(&"exp".to_string(), s, &mut memory);
        let ss = machine.get_register_contents_as_in_memory(&"exp".to_string(), &memory);
        assert_eq!(ss, String::from("( 1( 2() 3) 4(() 5))"));
    }

    #[test]
    fn machine_ops_bool_works() {
        let mut machine = BasicMachine::new();
        machine.add_semantic_op("self_evaluating".to_string(), is_self_evaluating);
        let exp1 = scheme_list!(Exp::SchemeString("winter is coming".to_string()));
        let exp2 = scheme_list!(Exp::Symbol("x".to_string()));
        assert_eq!(
            machine.call_semantic_op("self_evaluating".to_string(), &exp1.clone()),
            Exp::Bool(true)
        );
        assert_eq!(
            machine.call_semantic_op("self_evaluating".to_string(), &exp2.clone()),
            Exp::Bool(false)
        );
        machine.add_semantic_op("is_variable".to_string(), is_variable);
        assert_eq!(
            machine.call_semantic_op("is_variable".to_string(), &exp2),
            Exp::Bool(true)
        );
        assert_eq!(
            machine.call_semantic_op("is_variable".to_string(), &exp1),
            Exp::Bool(false)
        );
    }

    #[test]
    fn machine_ops_exp_works() {
        let mut machine = BasicMachine::new();
        machine.add_semantic_op("assignment_variable".to_string(), assignment_variable);
        let assisgn_exp = "(assign a (reg b ))".to_string();
        let assign = scheme_list!(str_to_exp(assisgn_exp));
        let var = machine.call_semantic_op("assignment_variable".to_string(), &assign);
        assert_eq!(var, Exp::Symbol("a".to_string()));
        machine.add_semantic_op("make_procedure".to_string(), make_procedure);
        let lambda_exp = "(lambda (x) (* x x))".to_string();
        let lambda = str_to_exp(lambda_exp);
        let parameters = cadr(&lambda).unwrap();
        let body = caddr(&lambda).unwrap();
        let args = scheme_list!(parameters.clone(), body.clone());
        let proc = machine.call_semantic_op("make_procedure".to_string(), &args);
        let tag = Exp::Symbol("procedure".to_string());
        assert_eq!(proc, scheme_list!(tag, parameters, body));
    }

    #[test]
    fn machine_ops_works() {
        let mut machine = BasicMachine::new();
        machine.add_machine_op("machine_statistics".to_string(), machine_statistics);
        let mut memory = Memory::new(10);
        assert_eq!(
            machine.is_machine_op(&"machine_statistics".to_string()),
            true
        );
        machine.call_machine_op("machine_statistics".to_string(), &mut memory);
    }

    #[test]
    fn initialize_env_works() {
        let mut machine = BasicMachine::new();
        let mut memory = Memory::new(100);
        machine.initilize_registers();
        machine.initialize_env(&mut memory);
        let env = machine.get_register_contents_as_in_memory(&"env".to_string(), &memory);
        let args = scheme_list!(Exp::Symbol("cons".to_string()), str_to_exp(env));
        let r = lookup_variable_value(&args);
        assert_eq!(r, str_to_exp("(primitive cons)".to_string()));
    }

    #[test]
    fn initialize_op_works() {
        let mut machine = BasicMachine::new();
        machine.initialize_op();
        assert_eq!(machine.machine_ops.contains_key(&"read".to_string()), true);
        assert_eq!(
            machine
                .machine_ops
                .contains_key(&"machine-statistics".to_string()),
            true
        );
        assert_eq!(
            machine
                .semantic_ops
                .contains_key(&"tagged-list?".to_string()),
            true
        );
        assert_eq!(
            machine
                .semantic_ops
                .contains_key(&"extend-environment".to_string()),
            true
        );
        assert_eq!(
            machine
                .semantic_ops
                .contains_key(&"lookup-variable-value".to_string()),
            true
        );
        assert_eq!(
            machine
                .semantic_ops
                .contains_key(&"rest-operands".to_string()),
            true
        );
    }
}
